# Backend Code - DeepSeek RAG Project

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/server.py
import os
import shutil
import asyncio
from typing import List, Optional
from fastapi import FastAPI, HTTPException, UploadFile, File, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from dotenv import load_dotenv

# å¯¼å…¥ç®¡ç†å™¨æ¨¡å—
from session_manager import session_manager, ChatSession, ChatMessage
from upload_manager import upload_manager, UploadTask

load_dotenv()

app = FastAPI(title="DeepSeek RAG API - å¢å¼ºç‰ˆ")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# æ•°æ®ç›®å½•
DATA_DIR = "../data"
os.makedirs(DATA_DIR, exist_ok=True)

class ChatRequest(BaseModel):
    input: str
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    output: str
    session_id: str

class FileInfo(BaseModel):
    name: str
    size: int
    type: str

# ä¼šè¯ç›¸å…³æ¨¡å‹
class SessionCreateRequest(BaseModel):
    title: Optional[str] = None

class SessionResponse(BaseModel):
    id: str
    title: str
    created_at: str
    updated_at: str
    message_count: int

class MessageResponse(BaseModel):
    id: str
    session_id: str
    role: str
    content: str
    timestamp: str

# ä¸Šä¼ ç›¸å…³æ¨¡å‹
class UploadStartRequest(BaseModel):
    filename: str
    total_size: int

class UploadStartResponse(BaseModel):
    task_id: str
    message: str

class UploadTaskResponse(BaseModel):
    id: str
    filename: str
    total_size: int
    uploaded_size: int
    status: str
    progress: float
    created_at: str
    updated_at: str
    error_message: Optional[str] = None

# æ‡’åˆå§‹åŒ–ç®€å•æ™ºèƒ½ä½“
_simple_agent = None

@app.on_event("startup")
def startup_event():
    global _simple_agent
    try:
        from simple_agent import get_simple_agent
        _simple_agent = get_simple_agent()
        print("âœ… ç®€åŒ–ç‰ˆæ™ºèƒ½ä½“åˆå§‹åŒ–æˆåŠŸ")
    except Exception as e:
        print(f"âŒ æ™ºèƒ½ä½“åˆå§‹åŒ–å¤±è´¥: {e}")
        _simple_agent = None

@app.get("/")
def root():
    return {"message": "DeepSeek RAG API - ç®€åŒ–ç‰ˆè¿è¡Œä¸­"}

@app.post("/api/chat", response_model=ChatResponse)
async def chat(req: ChatRequest):
    global _simple_agent
    if _simple_agent is None:
        raise HTTPException(status_code=503, detail="æ™ºèƒ½ä½“æœåŠ¡æš‚ä¸å¯ç”¨")

    try:
        # å¤„ç†ä¼šè¯ID
        session_id = req.session_id
        if not session_id:
            # å¦‚æœæ²¡æœ‰æä¾›ä¼šè¯IDï¼Œåˆ›å»ºæ–°ä¼šè¯
            session_id = session_manager.create_session()
        else:
            # éªŒè¯ä¼šè¯æ˜¯å¦å­˜åœ¨
            session = session_manager.get_session(session_id)
            if not session:
                session_id = session_manager.create_session()

        # è®°å½•ç”¨æˆ·æ¶ˆæ¯
        session_manager.add_message(session_id, "user", req.input)

        # å¤„ç†AIå“åº”
        res = _simple_agent.invoke({"input": req.input})
        if isinstance(res, dict):
            out = res.get("output") or res.get("result") or str(res)
        else:
            out = str(res)

        # è®°å½•AIå“åº”
        session_manager.add_message(session_id, "assistant", out)

        return ChatResponse(output=out, session_id=session_id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"å¤„ç†è¯·æ±‚æ—¶å‡ºé”™: {str(e)}")

@app.get("/health")
def health_check():
    return {"status": "healthy", "agent": _simple_agent is not None}

# æ–‡ä»¶ç®¡ç†API
@app.get("/api/files", response_model=List[FileInfo])
async def list_files():
    """åˆ—å‡ºçŸ¥è¯†åº“ä¸­çš„æ‰€æœ‰æ–‡ä»¶"""
    try:
        files = []
        for filename in os.listdir(DATA_DIR):
            filepath = os.path.join(DATA_DIR, filename)
            if os.path.isfile(filepath):
                stat = os.stat(filepath)
                files.append(FileInfo(
                    name=filename,
                    size=stat.st_size,
                    type=filename.split('.')[-1] if '.' in filename else 'unknown'
                ))
        return files
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"åˆ—å‡ºæ–‡ä»¶å¤±è´¥: {str(e)}")

@app.post("/api/upload")
async def upload_file(file: UploadFile = File(...)):
    """ä¸Šä¼ æ–‡ä»¶åˆ°çŸ¥è¯†åº“"""
    try:
        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        allowed_types = ['.txt', '.md', '.pdf', '.docx', '.doc']
        file_ext = os.path.splitext(file.filename)[1].lower()

        if file_ext not in allowed_types:
            raise HTTPException(
                status_code=400,
                detail=f"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚æ”¯æŒçš„ç±»å‹: {', '.join(allowed_types)}"
            )

        # ä¿å­˜æ–‡ä»¶
        file_path = os.path.join(DATA_DIR, file.filename)

        # å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
        counter = 1
        original_name = file.filename
        while os.path.exists(file_path):
            name, ext = os.path.splitext(original_name)
            file.filename = f"{name}_{counter}{ext}"
            file_path = os.path.join(DATA_DIR, file.filename)
            counter += 1

        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # é‡æ–°åŠ è½½RAGå¼•æ“
        global _simple_agent
        if _simple_agent:
            from simple_agent import get_simple_agent
            _simple_agent = get_simple_agent()
            # å¼ºåˆ¶é‡æ–°åŠ è½½æ–‡æ¡£
            from simple_rag import get_rag_engine
            rag_engine = get_rag_engine()
            rag_engine.load_documents()

        return {
            "message": "æ–‡ä»¶ä¸Šä¼ æˆåŠŸ",
            "filename": file.filename,
            "size": os.path.getsize(file_path)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {str(e)}")

@app.get("/api/download/{filename}")
async def download_file(filename: str):
    """ä¸‹è½½çŸ¥è¯†åº“ä¸­çš„æ–‡ä»¶"""
    try:
        file_path = os.path.join(DATA_DIR, filename)

        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ¨")

        if not os.path.isfile(file_path):
            raise HTTPException(status_code=400, detail="ä¸æ˜¯æœ‰æ•ˆæ–‡ä»¶")

        return FileResponse(
            path=file_path,
            filename=filename,
            media_type='application/octet-stream'
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {str(e)}")

@app.delete("/api/files/{filename}")
async def delete_file(filename: str):
    """åˆ é™¤çŸ¥è¯†åº“ä¸­çš„æ–‡ä»¶"""
    try:
        file_path = os.path.join(DATA_DIR, filename)

        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ¨")

        if not os.path.isfile(file_path):
            raise HTTPException(status_code=400, detail="ä¸æ˜¯æœ‰æ•ˆæ–‡ä»¶")

        os.remove(file_path)

        # é‡æ–°åŠ è½½RAGå¼•æ“
        global _simple_agent
        if _simple_agent:
            from simple_agent import get_simple_agent
            _simple_agent = get_simple_agent()
            # å¼ºåˆ¶é‡æ–°åŠ è½½æ–‡æ¡£
            from simple_rag import get_rag_engine
            rag_engine = get_rag_engine()
            rag_engine.load_documents()

        return {"message": f"æ–‡ä»¶ {filename} åˆ é™¤æˆåŠŸ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ–‡ä»¶åˆ é™¤å¤±è´¥: {str(e)}")

# ===== ä¼šè¯ç®¡ç† API =====

@app.post("/api/sessions", response_model=SessionResponse)
def create_session(req: SessionCreateRequest):
    """åˆ›å»ºæ–°ä¼šè¯"""
    try:
        session_id = session_manager.create_session(req.title)
        session = session_manager.get_session(session_id)
        return SessionResponse(
            id=session.id,
            title=session.title,
            created_at=session.created_at,
            updated_at=session.updated_at,
            message_count=session.message_count
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"åˆ›å»ºä¼šè¯å¤±è´¥: {str(e)}")

@app.get("/api/sessions", response_model=List[SessionResponse])
def get_sessions(limit: int = 50, offset: int = 0):
    """è·å–ä¼šè¯åˆ—è¡¨"""
    try:
        sessions = session_manager.get_sessions(limit, offset)
        return [
            SessionResponse(
                id=s.id,
                title=s.title,
                created_at=s.created_at,
                updated_at=s.updated_at,
                message_count=s.message_count
            ) for s in sessions
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¼šè¯åˆ—è¡¨å¤±è´¥: {str(e)}")

@app.get("/api/sessions/{session_id}", response_model=SessionResponse)
def get_session(session_id: str):
    """è·å–å•ä¸ªä¼šè¯"""
    try:
        session = session_manager.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="ä¼šè¯ä¸å­˜åœ¨")

        return SessionResponse(
            id=session.id,
            title=session.title,
            created_at=session.created_at,
            updated_at=session.updated_at,
            message_count=session.message_count
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¼šè¯å¤±è´¥: {str(e)}")

@app.get("/api/sessions/{session_id}/messages", response_model=List[MessageResponse])
def get_session_messages(session_id: str):
    """è·å–ä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯"""
    try:
        messages = session_manager.get_session_messages(session_id)
        return [
            MessageResponse(
                id=m.id,
                session_id=m.session_id,
                role=m.role,
                content=m.content,
                timestamp=m.timestamp
            ) for m in messages
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¼šè¯æ¶ˆæ¯å¤±è´¥: {str(e)}")

@app.put("/api/sessions/{session_id}/title")
def update_session_title(session_id: str, title: str):
    """æ›´æ–°ä¼šè¯æ ‡é¢˜"""
    try:
        success = session_manager.update_session_title(session_id, title)
        if not success:
            raise HTTPException(status_code=404, detail="ä¼šè¯ä¸å­˜åœ¨")
        return {"message": "ä¼šè¯æ ‡é¢˜æ›´æ–°æˆåŠŸ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ›´æ–°ä¼šè¯æ ‡é¢˜å¤±è´¥: {str(e)}")

@app.delete("/api/sessions/{session_id}")
def delete_session(session_id: str):
    """åˆ é™¤ä¼šè¯"""
    try:
        success = session_manager.delete_session(session_id)
        if not success:
            raise HTTPException(status_code=404, detail="ä¼šè¯ä¸å­˜åœ¨")
        return {"message": "ä¼šè¯åˆ é™¤æˆåŠŸ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"åˆ é™¤ä¼šè¯å¤±è´¥: {str(e)}")

@app.get("/api/sessions/search")
def search_sessions(q: str, limit: int = 20):
    """æœç´¢ä¼šè¯"""
    try:
        sessions = session_manager.search_sessions(q, limit)
        return [
            SessionResponse(
                id=s.id,
                title=s.title,
                created_at=s.created_at,
                updated_at=s.updated_at,
                message_count=s.message_count
            ) for s in sessions
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æœç´¢ä¼šè¯å¤±è´¥: {str(e)}")

@app.get("/api/sessions/stats")
def get_session_stats():
    """è·å–ä¼šè¯ç»Ÿè®¡ä¿¡æ¯"""
    try:
        stats = session_manager.get_session_stats()
        return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {str(e)}")

# ===== æ–‡ä»¶ä¸Šä¼ ç®¡ç† API =====

@app.post("/api/upload/start", response_model=UploadStartResponse)
def start_upload(req: UploadStartRequest):
    """å¼€å§‹æ–‡ä»¶ä¸Šä¼ ä»»åŠ¡"""
    try:
        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        allowed_types = ['.txt', '.md', '.pdf', '.docx', '.doc']
        file_ext = os.path.splitext(req.filename)[1].lower()

        if file_ext not in allowed_types:
            raise HTTPException(
                status_code=400,
                detail=f"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚æ”¯æŒçš„ç±»å‹: {', '.join(allowed_types)}"
            )

        task_id = upload_manager.create_upload_task(req.filename, req.total_size)
        return UploadStartResponse(
            task_id=task_id,
            message="ä¸Šä¼ ä»»åŠ¡åˆ›å»ºæˆåŠŸ"
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"åˆ›å»ºä¸Šä¼ ä»»åŠ¡å¤±è´¥: {str(e)}")

@app.post("/api/upload/{task_id}")
async def upload_file_chunk(task_id: str, file: UploadFile = File(...)):
    """ä¸Šä¼ æ–‡ä»¶å†…å®¹"""
    try:
        task = upload_manager.get_task(task_id)
        if not task:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨")

        # éªŒè¯æ–‡ä»¶åå’Œå¤§å°
        if file.filename != task.filename:
            raise HTTPException(status_code=400, detail="æ–‡ä»¶åä¸åŒ¹é…")

        content_length = file.size if hasattr(file, 'size') else 0
        if content_length > 0 and content_length != task.total_size:
            raise HTTPException(status_code=400, detail="æ–‡ä»¶å¤§å°ä¸åŒ¹é…")

        # å¼€å§‹ä¸Šä¼ 
        success = await upload_manager.start_upload(task_id, file)

        if success:
            # é‡æ–°åŠ è½½RAGå¼•æ“
            global _simple_agent
            if _simple_agent:
                from simple_agent import get_simple_agent
                _simple_agent = get_simple_agent()
                from simple_rag import get_rag_engine
                rag_engine = get_rag_engine()
                rag_engine.load_documents()

            return {"message": "æ–‡ä»¶ä¸Šä¼ æˆåŠŸ", "task_id": task_id}
        else:
            raise HTTPException(status_code=500, detail="æ–‡ä»¶ä¸Šä¼ å¤±è´¥")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ä¸Šä¼ æ–‡ä»¶å¤±è´¥: {str(e)}")

@app.get("/api/upload/{task_id}", response_model=UploadTaskResponse)
def get_upload_task(task_id: str):
    """è·å–ä¸Šä¼ ä»»åŠ¡çŠ¶æ€"""
    try:
        task = upload_manager.get_task(task_id)
        if not task:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨")

        return UploadTaskResponse(
            id=task.id,
            filename=task.filename,
            total_size=task.total_size,
            uploaded_size=task.uploaded_size,
            status=task.status,
            progress=task.progress,
            created_at=task.created_at,
            updated_at=task.updated_at,
            error_message=task.error_message
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¸Šä¼ ä»»åŠ¡å¤±è´¥: {str(e)}")

@app.get("/api/uploads", response_model=List[UploadTaskResponse])
def get_all_upload_tasks():
    """è·å–æ‰€æœ‰ä¸Šä¼ ä»»åŠ¡"""
    try:
        tasks = upload_manager.get_all_tasks()
        return [
            UploadTaskResponse(
                id=t.id,
                filename=t.filename,
                total_size=t.total_size,
                uploaded_size=t.uploaded_size,
                status=t.status,
                progress=t.progress,
                created_at=t.created_at,
                updated_at=t.updated_at,
                error_message=t.error_message
            ) for t in tasks.values()
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¸Šä¼ ä»»åŠ¡åˆ—è¡¨å¤±è´¥: {str(e)}")

@app.post("/api/upload/{task_id}/pause")
def pause_upload(task_id: str):
    """æš‚åœä¸Šä¼ """
    try:
        success = upload_manager.pause_upload(task_id)
        if not success:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨æˆ–æ— æ³•æš‚åœ")
        return {"message": "ä¸Šä¼ å·²æš‚åœ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æš‚åœä¸Šä¼ å¤±è´¥: {str(e)}")

@app.post("/api/upload/{task_id}/resume")
def resume_upload(task_id: str):
    """æ¢å¤ä¸Šä¼ """
    try:
        success = upload_manager.resume_upload(task_id)
        if not success:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨æˆ–æ— æ³•æ¢å¤")
        return {"message": "ä¸Šä¼ å·²æ¢å¤"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ¢å¤ä¸Šä¼ å¤±è´¥: {str(e)}")

@app.post("/api/upload/{task_id}/cancel")
def cancel_upload(task_id: str):
    """å–æ¶ˆä¸Šä¼ """
    try:
        success = upload_manager.cancel_upload(task_id)
        if not success:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨æˆ–æ— æ³•å–æ¶ˆ")
        return {"message": "ä¸Šä¼ å·²å–æ¶ˆ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"å–æ¶ˆä¸Šä¼ å¤±è´¥: {str(e)}")

@app.get("/api/upload/stats")
def get_upload_stats():
    """è·å–ä¸Šä¼ ç»Ÿè®¡ä¿¡æ¯"""
    try:
        stats = upload_manager.get_upload_stats()
        return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è·å–ä¸Šä¼ ç»Ÿè®¡å¤±è´¥: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("API_PORT", "8000"))
    uvicorn.run("backend.server:app", host="0.0.0.0", port=port, reload=True)

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/session_manager.py
"""
ä¼šè¯ç®¡ç†æ¨¡å—
æä¾›å†å²ä¼šè¯è®°å½•çš„å­˜å‚¨å’Œæ£€ç´¢åŠŸèƒ½
"""

import sqlite3
import json
import os
from datetime import datetime
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, asdict
import uuid

# æ•°æ®åº“æ–‡ä»¶è·¯å¾„
DB_DIR = "../data"
DB_PATH = os.path.join(DB_DIR, "sessions.db")

@dataclass
class ChatSession:
    """èŠå¤©ä¼šè¯æ•°æ®æ¨¡å‹"""
    id: str
    title: str
    created_at: str
    updated_at: str
    message_count: int
    metadata: Dict = None

@dataclass
class ChatMessage:
    """èŠå¤©æ¶ˆæ¯æ•°æ®æ¨¡å‹"""
    id: str
    session_id: str
    role: str  # 'user' or 'assistant'
    content: str
    timestamp: str
    metadata: Dict = None

class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨"""

    def __init__(self):
        self.init_database()

    def init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        os.makedirs(DB_DIR, exist_ok=True)

        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()

            # åˆ›å»ºä¼šè¯è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS sessions (
                    id TEXT PRIMARY KEY,
                    title TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL,
                    message_count INTEGER DEFAULT 0,
                    metadata TEXT
                )
            ''')

            # åˆ›å»ºæ¶ˆæ¯è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS messages (
                    id TEXT PRIMARY KEY,
                    session_id TEXT NOT NULL,
                    role TEXT NOT NULL,
                    content TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    metadata TEXT,
                    FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE
                )
            ''')

            # åˆ›å»ºç´¢å¼•
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_messages_session_id ON messages(session_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_sessions_updated_at ON sessions(updated_at)')

            conn.commit()

    def create_session(self, title: str = None) -> str:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_id = str(uuid.uuid4())
        now = datetime.now().isoformat()

        if not title:
            title = f"å¯¹è¯ {datetime.now().strftime('%m-%d %H:%M')}"

        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO sessions (id, title, created_at, updated_at, message_count, metadata)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (session_id, title, now, now, 0, '{}'))
            conn.commit()

        return session_id

    def add_message(self, session_id: str, role: str, content: str, metadata: Dict = None) -> str:
        """æ·»åŠ æ¶ˆæ¯åˆ°ä¼šè¯"""
        message_id = str(uuid.uuid4())
        now = datetime.now().isoformat()

        if metadata is None:
            metadata = {}

        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()

            # æ’å…¥æ¶ˆæ¯
            cursor.execute('''
                INSERT INTO messages (id, session_id, role, content, timestamp, metadata)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (message_id, session_id, role, content, now, json.dumps(metadata)))

            # æ›´æ–°ä¼šè¯çš„æ¶ˆæ¯æ•°é‡å’Œæ›´æ–°æ—¶é—´
            cursor.execute('''
                UPDATE sessions
                SET message_count = message_count + 1, updated_at = ?
                WHERE id = ?
            ''', (now, session_id))

            conn.commit()

        return message_id

    def get_sessions(self, limit: int = 50, offset: int = 0) -> List[ChatSession]:
        """è·å–ä¼šè¯åˆ—è¡¨"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT id, title, created_at, updated_at, message_count, metadata
                FROM sessions
                ORDER BY updated_at DESC
                LIMIT ? OFFSET ?
            ''', (limit, offset))

            sessions = []
            for row in cursor.fetchall():
                metadata = json.loads(row[5]) if row[5] else {}
                sessions.append(ChatSession(
                    id=row[0],
                    title=row[1],
                    created_at=row[2],
                    updated_at=row[3],
                    message_count=row[4],
                    metadata=metadata
                ))

            return sessions

    def get_session_messages(self, session_id: str) -> List[ChatMessage]:
        """è·å–ä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT id, session_id, role, content, timestamp, metadata
                FROM messages
                WHERE session_id = ?
                ORDER BY timestamp ASC
            ''', (session_id,))

            messages = []
            for row in cursor.fetchall():
                metadata = json.loads(row[5]) if row[5] else {}
                messages.append(ChatMessage(
                    id=row[0],
                    session_id=row[1],
                    role=row[2],
                    content=row[3],
                    timestamp=row[4],
                    metadata=metadata
                ))

            return messages

    def get_session(self, session_id: str) -> Optional[ChatSession]:
        """è·å–å•ä¸ªä¼šè¯"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT id, title, created_at, updated_at, message_count, metadata
                FROM sessions
                WHERE id = ?
            ''', (session_id,))

            row = cursor.fetchone()
            if row:
                metadata = json.loads(row[5]) if row[5] else {}
                return ChatSession(
                    id=row[0],
                    title=row[1],
                    created_at=row[2],
                    updated_at=row[3],
                    message_count=row[4],
                    metadata=metadata
                )
            return None

    def update_session_title(self, session_id: str, title: str) -> bool:
        """æ›´æ–°ä¼šè¯æ ‡é¢˜"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE sessions
                SET title = ?, updated_at = ?
                WHERE id = ?
            ''', (title, datetime.now().isoformat(), session_id))
            conn.commit()
            return cursor.rowcount > 0

    def delete_session(self, session_id: str) -> bool:
        """åˆ é™¤ä¼šè¯åŠå…¶æ‰€æœ‰æ¶ˆæ¯"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('DELETE FROM sessions WHERE id = ?', (session_id,))
            conn.commit()
            return cursor.rowcount > 0

    def search_sessions(self, query: str, limit: int = 20) -> List[ChatSession]:
        """æœç´¢ä¼šè¯"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT DISTINCT s.id, s.title, s.created_at, s.updated_at, s.message_count, s.metadata
                FROM sessions s
                LEFT JOIN messages m ON s.id = m.session_id
                WHERE s.title LIKE ? OR m.content LIKE ?
                ORDER BY s.updated_at DESC
                LIMIT ?
            ''', (f'%{query}%', f'%{query}%', limit))

            sessions = []
            for row in cursor.fetchall():
                metadata = json.loads(row[5]) if row[5] else {}
                sessions.append(ChatSession(
                    id=row[0],
                    title=row[1],
                    created_at=row[2],
                    updated_at=row[3],
                    message_count=row[4],
                    metadata=metadata
                ))

            return sessions

    def get_session_stats(self) -> Dict:
        """è·å–ä¼šè¯ç»Ÿè®¡ä¿¡æ¯"""
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()

            # æ€»ä¼šè¯æ•°
            cursor.execute('SELECT COUNT(*) FROM sessions')
            total_sessions = cursor.fetchone()[0]

            # æ€»æ¶ˆæ¯æ•°
            cursor.execute('SELECT COUNT(*) FROM messages')
            total_messages = cursor.fetchone()[0]

            # ä»Šæ—¥ä¼šè¯æ•°
            today = datetime.now().date().isoformat()
            cursor.execute('SELECT COUNT(*) FROM sessions WHERE created_at >= ?', (f'{today}T00:00:00',))
            today_sessions = cursor.fetchone()[0]

            return {
                'total_sessions': total_sessions,
                'total_messages': total_messages,
                'today_sessions': today_sessions
            }

# å…¨å±€ä¼šè¯ç®¡ç†å™¨å®ä¾‹
session_manager = SessionManager()

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/upload_manager.py
"""
æ–‡ä»¶ä¸Šä¼ ç®¡ç†æ¨¡å—
æä¾›æ–‡ä»¶ä¸Šä¼ è¿›åº¦è·Ÿè¸ªå’Œä¸­æ–­åŠŸèƒ½
"""

import os
import asyncio
import uuid
import json
import tempfile
from datetime import datetime
from typing import Dict, Optional, Callable
from dataclasses import dataclass, asdict
from fastapi import UploadFile, HTTPException
import aiofiles
import shutil

@dataclass
class UploadTask:
    """ä¸Šä¼ ä»»åŠ¡æ•°æ®æ¨¡å‹"""
    id: str
    filename: str
    total_size: int
    uploaded_size: int = 0
    status: str = "pending"  # pending, uploading, paused, completed, failed, cancelled
    progress: float = 0.0
    created_at: str = None
    updated_at: str = None
    temp_file_path: str = None
    final_file_path: str = None
    error_message: str = None

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now().isoformat()
        if self.updated_at is None:
            self.updated_at = datetime.now().isoformat()

class UploadManager:
    """ä¸Šä¼ ç®¡ç†å™¨"""

    def __init__(self, data_dir: str = "../data"):
        self.data_dir = data_dir
        self.tasks: Dict[str, UploadTask] = {}
        self.chunk_size = 1024 * 1024  # 1MB chunks
        os.makedirs(data_dir, exist_ok=True)
        os.makedirs(os.path.join(data_dir, "temp"), exist_ok=True)

    def create_upload_task(self, filename: str, total_size: int) -> str:
        """åˆ›å»ºä¸Šä¼ ä»»åŠ¡"""
        task_id = str(uuid.uuid4())
        temp_filename = f"temp_{task_id}_{filename}"
        temp_file_path = os.path.join(self.data_dir, "temp", temp_filename)
        final_file_path = os.path.join(self.data_dir, filename)

        task = UploadTask(
            id=task_id,
            filename=filename,
            total_size=total_size,
            temp_file_path=temp_file_path,
            final_file_path=final_file_path,
            status="pending"
        )

        self.tasks[task_id] = task
        return task_id

    def get_task(self, task_id: str) -> Optional[UploadTask]:
        """è·å–ä¸Šä¼ ä»»åŠ¡"""
        return self.tasks.get(task_id)

    def get_all_tasks(self) -> Dict[str, UploadTask]:
        """è·å–æ‰€æœ‰ä¸Šä¼ ä»»åŠ¡"""
        return self.tasks.copy()

    def update_task_progress(self, task_id: str, uploaded_size: int, status: str = None) -> bool:
        """æ›´æ–°ä¸Šä¼ ä»»åŠ¡è¿›åº¦"""
        if task_id not in self.tasks:
            return False

        task = self.tasks[task_id]
        task.uploaded_size = uploaded_size
        task.progress = min(100.0, (uploaded_size / task.total_size) * 100)
        task.updated_at = datetime.now().isoformat()

        if status:
            task.status = status

        return True

    async def start_upload(self, task_id: str, file: UploadFile,
                          progress_callback: Optional[Callable] = None) -> bool:
        """å¼€å§‹æ–‡ä»¶ä¸Šä¼ """
        if task_id not in self.tasks:
            raise HTTPException(status_code=404, detail="ä¸Šä¼ ä»»åŠ¡ä¸å­˜åœ¨")

        task = self.tasks[task_id]

        try:
            task.status = "uploading"

            # å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼ˆæ¢å¤ä¸Šä¼ ï¼‰ï¼Œè·å–å·²ä¸Šä¼ çš„å¤§å°
            if os.path.exists(task.temp_file_path):
                task.uploaded_size = os.path.getsize(task.temp_file_path)
                task.progress = (task.uploaded_size / task.total_size) * 100

            async with aiofiles.open(task.temp_file_path, 'ab') as temp_file:
                # è·³è¿‡å·²ä¸Šä¼ çš„éƒ¨åˆ†
                if task.uploaded_size > 0:
                    await file.seek(task.uploaded_size)

                while True:
                    # æ£€æŸ¥ä»»åŠ¡çŠ¶æ€
                    if task.status == "cancelled":
                        return False

                    if task.status == "paused":
                        await asyncio.sleep(0.1)
                        continue

                    # è¯»å–æ•°æ®å—
                    chunk = await file.read(self.chunk_size)
                    if not chunk:
                        break

                    # å†™å…¥ä¸´æ—¶æ–‡ä»¶
                    await temp_file.write(chunk)
                    task.uploaded_size += len(chunk)
                    task.progress = (task.uploaded_size / task.total_size) * 100
                    task.updated_at = datetime.now().isoformat()

                    # è°ƒç”¨è¿›åº¦å›è°ƒ
                    if progress_callback:
                        await progress_callback(task)

            # æ£€æŸ¥æ˜¯å¦ä¸Šä¼ å®Œæˆ
            if task.uploaded_size >= task.total_size:
                await self.complete_upload(task_id)
                return True
            else:
                task.status = "failed"
                task.error_message = "ä¸Šä¼ ä¸å®Œæ•´"
                return False

        except Exception as e:
            task.status = "failed"
            task.error_message = str(e)
            return False

    async def complete_upload(self, task_id: str) -> bool:
        """å®Œæˆä¸Šä¼ ï¼Œå°†ä¸´æ—¶æ–‡ä»¶ç§»åŠ¨åˆ°æœ€ç»ˆä½ç½®"""
        if task_id not in self.tasks:
            return False

        task = self.tasks[task_id]

        try:
            # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™ç”Ÿæˆæ–°æ–‡ä»¶å
            final_path = task.final_file_path
            counter = 1
            original_name = task.filename

            while os.path.exists(final_path):
                name, ext = os.path.splitext(original_name)
                new_filename = f"{name}_{counter}{ext}"
                final_path = os.path.join(self.data_dir, new_filename)
                counter += 1

            # ç§»åŠ¨æ–‡ä»¶åˆ°æœ€ç»ˆä½ç½®
            shutil.move(task.temp_file_path, final_path)

            task.status = "completed"
            task.progress = 100.0
            task.final_file_path = final_path
            task.updated_at = datetime.now().isoformat()

            return True

        except Exception as e:
            task.status = "failed"
            task.error_message = str(e)
            return False

    def pause_upload(self, task_id: str) -> bool:
        """æš‚åœä¸Šä¼ """
        if task_id not in self.tasks:
            return False

        task = self.tasks[task_id]
        if task.status == "uploading":
            task.status = "paused"
            task.updated_at = datetime.now().isoformat()
            return True
        return False

    def resume_upload(self, task_id: str) -> bool:
        """æ¢å¤ä¸Šä¼ """
        if task_id not in self.tasks:
            return False

        task = self.tasks[task_id]
        if task.status == "paused":
            task.status = "uploading"
            task.updated_at = datetime.now().isoformat()
            return True
        return False

    def cancel_upload(self, task_id: str) -> bool:
        """å–æ¶ˆä¸Šä¼ """
        if task_id not in self.tasks:
            return False

        task = self.tasks[task_id]
        task.status = "cancelled"
        task.updated_at = datetime.now().isoformat()

        # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
        if task.temp_file_path and os.path.exists(task.temp_file_path):
            try:
                os.remove(task.temp_file_path)
            except:
                pass

        return True

    def cleanup_completed_tasks(self, max_age_hours: int = 24):
        """æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡"""
        current_time = datetime.now()
        tasks_to_remove = []

        for task_id, task in self.tasks.items():
            if task.status in ["completed", "failed", "cancelled"]:
                task_time = datetime.fromisoformat(task.updated_at)
                age_hours = (current_time - task_time).total_seconds() / 3600

                if age_hours > max_age_hours:
                    # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
                    if task.temp_file_path and os.path.exists(task.temp_file_path):
                        try:
                            os.remove(task.temp_file_path)
                        except:
                            pass
                    tasks_to_remove.append(task_id)

        for task_id in tasks_to_remove:
            del self.tasks[task_id]

    def get_upload_stats(self) -> Dict:
        """è·å–ä¸Šä¼ ç»Ÿè®¡ä¿¡æ¯"""
        stats = {
            "total_tasks": len(self.tasks),
            "pending": 0,
            "uploading": 0,
            "paused": 0,
            "completed": 0,
            "failed": 0,
            "cancelled": 0
        }

        for task in self.tasks.values():
            stats[task.status] += 1

        return stats

# å…¨å±€ä¸Šä¼ ç®¡ç†å™¨å®ä¾‹
upload_manager = UploadManager()

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/simple_rag.py
"""
ç®€åŒ–ç‰ˆ RAG å¼•æ“ - ç§»é™¤å¤æ‚çš„å…¼å®¹æ€§ä»£ç ï¼Œä¸“æ³¨æ ¸å¿ƒåŠŸèƒ½
"""
import os
import re
from dotenv import load_dotenv
from typing import List
try:
    import PyPDF2
except ImportError:
    PyPDF2 = None

try:
    from docx import Document
except ImportError:
    Document = None

load_dotenv()

# é…ç½®
EMBEDDING_MODEL = os.getenv("EMBEDDING_MODEL", "BAAI/bge-small-zh-v1.5")
MILVUS_URI = os.getenv("MILVUS_URI", "tcp://localhost:19530")
DATA_DIR = "./data"

def extract_query_terms(query: str) -> List[str]:
    """æå–æŸ¥è¯¢å…³é”®è¯ï¼Œå…¼é¡¾ä¸­æ–‡æ— ç©ºæ ¼çš„åœºæ™¯"""
    # å…ˆæŒ‰å¸¸è§åˆ†éš”ç¬¦åˆ‡åˆ†
    raw_tokens = re.split(r"[,\sï¼Œã€‚ï¼ï¼Ÿï¼š;ï¼›:?!()\[\]{}<>""'Â·ã€/\\]+", query)
    keywords: List[str] = []

    for token in raw_tokens:
        token = token.strip()
        if not token:
            continue
        # çº¯ä¸­æ–‡ä¸”è¾ƒé•¿æ—¶ï¼Œåˆ‡æˆåŒå­—çª—å£ï¼Œå¢å¼ºåŒ¹é…æœºä¼š
        if re.fullmatch(r"[\u4e00-\u9fff]+", token) and len(token) >= 4:
            keywords.extend([token[i:i+2] for i in range(len(token) - 1)])
        else:
            keywords.append(token)

    # å»é‡å¹¶è¿‡æ»¤é•¿åº¦è¿‡çŸ­çš„ token
    keywords = [kw for kw in dict.fromkeys(keywords) if len(kw) >= 2]

    # å¦‚æœä¾æ—§æ²¡æœ‰å…³é”®è¯ï¼Œåˆ™é€€åŒ–ä¸ºä¸­æ–‡å•å­—ç»„åˆ
    if not keywords:
        chars = re.findall(r"[\u4e00-\u9fff]", query)
        keywords = [''.join(chars[i:i+2]) for i in range(len(chars) - 1)]

    return keywords

def create_sample_docs() -> List[str]:
    """åˆ›å»ºç¤ºä¾‹æ–‡æ¡£ï¼Œç”¨äºæ¼”ç¤º"""
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)

    sample_file = os.path.join(DATA_DIR, "sample.txt")
    if not os.path.exists(sample_file):
        sample_content = """å…¬å¸å†…éƒ¨çŸ¥è¯†åº“ç¤ºä¾‹

ä¸€ã€å…¬å¸æ”¿ç­–
1. å·¥ä½œæ—¶é—´ï¼šå‘¨ä¸€è‡³å‘¨äº” 9:00-18:00
2. å¹´å‡åˆ¶åº¦ï¼šå·¥ä½œæ»¡1å¹´äº«å—5å¤©å¹´å‡
3. è¿œç¨‹åŠå…¬ï¼šç‰¹æ®Šæƒ…å†µå¯ç”³è¯·è¿œç¨‹åŠå…¬

äºŒã€æŠ€æœ¯è§„èŒƒ
1. ä»£ç è§„èŒƒï¼šéµå¾ªPEP8æ ‡å‡†
2. ç‰ˆæœ¬æ§åˆ¶ï¼šä½¿ç”¨Gitç®¡ç†ä»£ç 
3. æµ‹è¯•è¦æ±‚ï¼šæ‰€æœ‰æ–°åŠŸèƒ½éœ€è¦ç¼–å†™å•å…ƒæµ‹è¯•

ä¸‰ã€é¡¹ç›®æµç¨‹
1. éœ€æ±‚åˆ†æï¼šä¸äº§å“ç»ç†ç¡®è®¤éœ€æ±‚
2. å¼€å‘å®ç°ï¼šæŒ‰ç…§æŠ€æœ¯è§„èŒƒè¿›è¡Œå¼€å‘
3. ä»£ç å®¡æŸ¥ï¼šåŒäº‹ä¹‹é—´è¿›è¡Œä»£ç å®¡æŸ¥
4. éƒ¨ç½²ä¸Šçº¿ï¼šé€šè¿‡CI/CDæµç¨‹éƒ¨ç½²

å››ã€å¸¸è§é—®é¢˜
1. VPNè¿æ¥ï¼šä½¿ç”¨å…¬å¸æä¾›çš„VPNæœåŠ¡
2. é‚®ç®±è®¾ç½®ï¼šä½¿ç”¨ä¼ä¸šé‚®ç®±ç³»ç»Ÿ
3. ä¼šè®®é¢„å®šï¼šä½¿ç”¨å…¬å¸çš„ä¼šè®®é¢„å®šç³»ç»Ÿ
"""
        with open(sample_file, 'w', encoding='utf-8') as f:
            f.write(sample_content)

    return [sample_file]

class SimpleRAGEngine:
    """ç®€åŒ–çš„RAGå¼•æ“ï¼Œä»…ä½¿ç”¨æœ¬åœ°æ–‡ä»¶å’ŒåŸºæœ¬æ–‡æœ¬æœç´¢"""

    def __init__(self):
        self.documents = {}
        self.load_documents()

    def extract_text_from_file(self, filepath: str) -> str:
        """ä»ä¸åŒæ ¼å¼çš„æ–‡ä»¶ä¸­æå–æ–‡æœ¬"""
        try:
            ext = os.path.splitext(filepath)[1].lower()

            if ext == '.txt' or ext == '.md':
                with open(filepath, 'r', encoding='utf-8') as f:
                    return f.read()

            elif ext == '.pdf' and PyPDF2 is not None:
                text = ""
                with open(filepath, 'rb') as f:
                    reader = PyPDF2.PdfReader(f)
                    for page in reader.pages:
                        text += page.extract_text() + "\n"
                return text

            elif ext in ['.docx', '.doc'] and Document is not None:
                doc = Document(filepath)
                text = ""
                for paragraph in doc.paragraphs:
                    text += paragraph.text + "\n"
                return text

            else:
                if ext in ['.pdf', '.docx', '.doc']:
                    print(f"âš ï¸ ç¼ºå°‘{ext}æ–‡ä»¶å¤„ç†ä¾èµ–ï¼Œè¯·å®‰è£…: PyPDF2 (PDF), python-docx (Word)")
                else:
                    print(f"âš ï¸ ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {ext}")
                return ""

        except Exception as e:
            print(f"âŒ æ–‡ä»¶å†…å®¹æå–å¤±è´¥ {filepath}: {e}")
            return ""

    def load_documents(self):
        """åŠ è½½æ–‡æ¡£å†…å®¹"""
        # ç¡®ä¿æœ‰ç¤ºä¾‹æ–‡æ¡£
        create_sample_docs()

        if os.path.exists(DATA_DIR):
            for filename in os.listdir(DATA_DIR):
                if filename.endswith(('.txt', '.md', '.pdf', '.docx', '.doc')):
                    filepath = os.path.join(DATA_DIR, filename)
                    try:
                        content = self.extract_text_from_file(filepath)
                        if content.strip():
                            self.documents[filename] = content
                            print(f"âœ… å·²åŠ è½½æ–‡æ¡£: {filename}")
                        else:
                            print(f"âš ï¸ æ–‡ä»¶å†…å®¹ä¸ºç©ºæˆ–æ— æ³•æå–: {filename}")
                    except Exception as e:
                        print(f"âŒ åŠ è½½æ–‡æ¡£å¤±è´¥ {filename}: {e}")

    def search(self, query: str, top_k: int = 3) -> List[str]:
        """æ”¹è¿›çš„æœç´¢ç®—æ³•ï¼šæ”¯æŒåˆ†è¯å’Œå…³é”®è¯åŒ¹é…"""
        results = []
        query_lower = query.lower()

        # æå–æŸ¥è¯¢ä¸­çš„å…³é”®è¯ï¼ˆå¢å¼ºä¸­æ–‡åŒ¹é…èƒ½åŠ›ï¼‰
        query_words = extract_query_terms(query_lower)

        for filename, content in self.documents.items():
            content_lower = content.lower()

            # 1. å®Œæ•´æŸ¥è¯¢åŒ¹é…
            if query_lower in content_lower:
                paragraphs = content.split('\n\n')
                for paragraph in paragraphs:
                    if query_lower in paragraph.lower():
                        results.append(f"[{filename}] {paragraph.strip()}")
                        if len(results) >= top_k:
                            return results

            # 2. å…³é”®è¯åŒ¹é…ï¼ˆå¦‚æœå®Œæ•´åŒ¹é…å¤±è´¥ï¼‰
            elif any(word in content_lower for word in query_words):
                paragraphs = content.split('\n\n')
                for paragraph in paragraphs:
                    paragraph_lower = paragraph.lower()
                    # åŒ¹é…åŒ…å«å¤šä¸ªå…³é”®è¯çš„æ®µè½
                    matched_words = sum(1 for word in query_words if word in paragraph_lower)
                    if matched_words >= min(2, len(query_words)):  # è‡³å°‘åŒ¹é…2ä¸ªè¯æˆ–æ‰€æœ‰è¯
                        results.append(f"[{filename}] {paragraph.strip()}")
                        if len(results) >= top_k:
                            return results

        # 3. å¦‚æœè¿˜æ²¡æœ‰ç»“æœï¼Œè¿”å›åŒ…å«ä»»ä¸€å…³é”®è¯çš„å†…å®¹
        if not results and query_words:
            for filename, content in self.documents.items():
                content_lower = content.lower()
                if any(word in content_lower for word in query_words):
                    # æ‰¾åˆ°åŒ…å«å…³é”®è¯çš„å¥å­
                    sentences = content.split('ã€‚')
                    for sentence in sentences:
                        sentence_lower = sentence.lower()
                        if any(word in sentence_lower for word in query_words):
                            results.append(f"[{filename}] {sentence.strip()}ã€‚")
                            if len(results) >= top_k:
                                return results

        return results if results else ["æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯"]

    def query(self, question: str) -> str:
        """æŸ¥è¯¢å¹¶ç”Ÿæˆå›ç­”"""
        search_results = self.search(question)

        if not search_results or search_results == ["æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯"]:
            return "æŠ±æ­‰ï¼Œæˆ‘åœ¨çŸ¥è¯†åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚è¿™ä¸ªé—®é¢˜å¯èƒ½éœ€è¦å’¨è¯¢ç›¸å…³éƒ¨é—¨åŒäº‹ã€‚"

        # ç®€å•çš„å›ç­”ç”Ÿæˆ
        answer = f"æ ¹æ®çŸ¥è¯†åº“ä¿¡æ¯ï¼š\n\n"
        for i, result in enumerate(search_results, 1):
            answer += f"{i}. {result}\n\n"

        answer += "ä»¥ä¸Šæ˜¯ç›¸å…³ä¿¡æ¯ï¼Œå¦‚æœéœ€è¦æ›´è¯¦ç»†çš„è§£ç­”ï¼Œå»ºè®®å’¨è¯¢ç›¸å…³éƒ¨é—¨åŒäº‹ã€‚"
        return answer

# å…¨å±€å®ä¾‹
_rag_engine = None

def get_rag_engine():
    """è·å–RAGå¼•æ“å®ä¾‹"""
    global _rag_engine
    if _rag_engine is None:
        _rag_engine = SimpleRAGEngine()
    return _rag_engine

if __name__ == "__main__":
    # æµ‹è¯•ä»£ç 
    engine = SimpleRAGEngine()
    print("=== RAGå¼•æ“æµ‹è¯• ===")
    test_queries = ["å·¥ä½œæ—¶é—´", "ä»£ç è§„èŒƒ", "å¹´å‡"]

    for query in test_queries:
        print(f"\né—®é¢˜: {query}")
        result = engine.query(query)
        print(f"å›ç­”: {result}")
        print("-" * 50)

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/simple_agent.py
"""
ç®€åŒ–ç‰ˆæ™ºèƒ½ä½“ - ç§»é™¤å¤æ‚çš„ LangChain ä¾èµ–ï¼Œä¸“æ³¨æ ¸å¿ƒå¯¹è¯åŠŸèƒ½
"""
import os
import requests
from typing import Dict, Any
from dotenv import load_dotenv
from simple_rag import get_rag_engine

load_dotenv()

class SimpleAgent:
    """ç®€åŒ–çš„æ™ºèƒ½ä½“ï¼Œæ•´åˆRAGå’ŒDeepSeek API"""

    def __init__(self):
        self.api_key = os.getenv("DEEPSEEK_API_KEY")
        self.base_url = os.getenv("DEEPSEEK_BASE_URL", "https://api.deepseek.com/v1")
        self.rag_engine = get_rag_engine()

    def _call_deepseek_api(self, messages: list) -> str:
        """è°ƒç”¨DeepSeek API"""
        if not self.api_key or self.api_key == "your_deepseek_api_key_here":
            return "DeepSeek API Key æœªé…ç½®ï¼Œè¯·å…ˆè®¾ç½® .env æ–‡ä»¶ä¸­çš„ DEEPSEEK_API_KEY"

        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }

            data = {
                "model": "deepseek-chat",
                "messages": messages,
                "temperature": 0.1,
                "max_tokens": 4096
            }

            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=data,
                timeout=30
            )

            if response.status_code == 200:
                result = response.json()
                return result["choices"][0]["message"]["content"]
            else:
                return f"APIè°ƒç”¨å¤±è´¥: {response.status_code} - {response.text}"

        except Exception as e:
            return f"è°ƒç”¨DeepSeek APIæ—¶å‡ºé”™: {str(e)}"

    def invoke(self, query_input: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†ç”¨æˆ·æŸ¥è¯¢"""
        if isinstance(query_input, str):
            user_query = query_input
        else:
            user_query = query_input.get("input", "")

        if not user_query:
            return {"output": "è¯·è¾“å…¥æ‚¨çš„é—®é¢˜ã€‚"}

        # é¦–å…ˆå°è¯•ä»RAGè·å–ä¿¡æ¯
        rag_result = self.rag_engine.query(user_query)

        # æ„å»ºç³»ç»Ÿæç¤ºè¯
        system_prompt = """ä½ æ˜¯ä¸€ä¸ªä¼ä¸šAIåŠ©æ‰‹ï¼Œå¸®åŠ©å‘˜å·¥æŸ¥è¯¢å†…éƒ¨çŸ¥è¯†åº“ã€‚

ä½ çš„å›ç­”åº”è¯¥ï¼š
1. ä¼˜å…ˆä½¿ç”¨RAGæ£€ç´¢åˆ°çš„å†…éƒ¨ä¿¡æ¯
2. å¦‚æœå†…éƒ¨ä¿¡æ¯ä¸å¤Ÿå®Œæ•´ï¼Œå¯ä»¥ç»“åˆå¸¸è¯†ç»™å‡ºè¡¥å……å»ºè®®
3. å›ç­”è¦ç®€æ´æ˜äº†ï¼Œåˆ†ç‚¹åˆ—å‡º
4. å¦‚æœä¸ç¡®å®šï¼Œå»ºè®®ç”¨æˆ·å’¨è¯¢ç›¸å…³éƒ¨é—¨åŒäº‹

ç°åœ¨æœ‰ç”¨æˆ·æé—®ï¼ŒåŒæ—¶æä¾›äº†ä¼ä¸šå†…éƒ¨çŸ¥è¯†åº“çš„æ£€ç´¢ç»“æœï¼š"""

        # æ„å»ºæ¶ˆæ¯
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": f"ç”¨æˆ·é—®é¢˜ï¼š{user_query}\n\nå†…éƒ¨çŸ¥è¯†åº“æ£€ç´¢ç»“æœï¼š\n{rag_result}"}
        ]

        # å¦‚æœæ²¡æœ‰API keyï¼Œç›´æ¥è¿”å›RAGç»“æœ
        if not self.api_key or self.api_key == "your_deepseek_api_key_here":
            return {"output": rag_result}

        # è°ƒç”¨DeepSeek APIç”Ÿæˆå›ç­”
        enhanced_answer = self._call_deepseek_api(messages)
        return {"output": enhanced_answer}

# å…¨å±€å®ä¾‹
_simple_agent = None

def get_simple_agent():
    """è·å–ç®€å•æ™ºèƒ½ä½“å®ä¾‹"""
    global _simple_agent
    if _simple_agent is None:
        _simple_agent = SimpleAgent()
    return _simple_agent

if __name__ == "__main__":
    # æµ‹è¯•ä»£ç 
    agent = SimpleAgent()
    print("=== ç®€å•æ™ºèƒ½ä½“æµ‹è¯• ===")
    test_inputs = [
        {"input": "å…¬å¸çš„å·¥ä½œæ—¶é—´æ˜¯ä»€ä¹ˆï¼Ÿ"},
        {"input": "ä»£ç è§„èŒƒæœ‰ä»€ä¹ˆè¦æ±‚ï¼Ÿ"},
        {"input": "å¦‚ä½•ç”³è¯·å¹´å‡ï¼Ÿ"}
    ]

    for test_input in test_inputs:
        print(f"\né—®é¢˜: {test_input['input']}")
        result = agent.invoke(test_input)
        print(f"å›ç­”: {result['output']}")
        print("-" * 60)

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/demo.py
#!/usr/bin/env python3
"""
ç®€åŒ–ç‰ˆ RAG ç³»ç»Ÿæ¼”ç¤ºè„šæœ¬
è¿è¡Œè¿™ä¸ªè„šæœ¬æ¥æµ‹è¯•æ•´ä¸ªç³»ç»ŸåŠŸèƒ½
"""
import os
import sys
from dotenv import load_dotenv

def print_banner():
    """æ‰“å°æ¨ªå¹…"""
    print("=" * 60)
    print("ğŸ¢ DeepSeek ä¼ä¸šçŸ¥è¯†åº“ RAG ç³»ç»Ÿ - ç®€åŒ–ç‰ˆæ¼”ç¤º")
    print("=" * 60)
    print()

def check_environment():
    """æ£€æŸ¥ç¯å¢ƒé…ç½®"""
    print("ğŸ“‹ æ£€æŸ¥ç¯å¢ƒé…ç½®...")

    # æ£€æŸ¥ .env æ–‡ä»¶
    if os.path.exists(".env"):
        print("âœ… .env æ–‡ä»¶å­˜åœ¨")
    else:
        print("âš ï¸  .env æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†ä½¿ç”¨é»˜è®¤é…ç½®")
        print("   å¯ä»¥å¤åˆ¶ .env.example æ–‡ä»¶åˆ›å»º .env æ–‡ä»¶")

    # æ£€æŸ¥æ•°æ®ç›®å½•
    data_dir = "./data"
    if os.path.exists(data_dir):
        print("âœ… æ•°æ®ç›®å½•å­˜åœ¨")
        files = os.listdir(data_dir)
        print(f"   åŒ…å« {len(files)} ä¸ªæ–‡ä»¶: {files}")
    else:
        print("âš ï¸  æ•°æ®ç›®å½•ä¸å­˜åœ¨ï¼Œå°†è‡ªåŠ¨åˆ›å»º")

    # æ£€æŸ¥ API Key
    load_dotenv()
    api_key = os.getenv("DEEPSEEK_API_KEY")
    if api_key and api_key != "your_deepseek_api_key_here":
        print("âœ… DeepSeek API Key å·²é…ç½®")
    else:
        print("âš ï¸  DeepSeek API Key æœªé…ç½®ï¼Œå°†ä½¿ç”¨æœ¬åœ°æœç´¢åŠŸèƒ½")

    print()

def test_rag_engine():
    """æµ‹è¯•RAGå¼•æ“"""
    print("ğŸ” æµ‹è¯• RAG æœç´¢å¼•æ“...")
    try:
        from simple_rag import get_rag_engine

        engine = get_rag_engine()

        test_queries = ["å·¥ä½œæ—¶é—´", "å¹´å‡åˆ¶åº¦", "ä»£ç è§„èŒƒ"]

        for query in test_queries:
            print(f"\nâ“ é—®é¢˜: {query}")
            result = engine.query(query)
            print(f"ğŸ“ å›ç­”: {result[:100]}...")

        print("âœ… RAG å¼•æ“æµ‹è¯•é€šè¿‡")

    except Exception as e:
        print(f"âŒ RAG å¼•æ“æµ‹è¯•å¤±è´¥: {e}")
        return False

    print()
    return True

def test_agent():
    """æµ‹è¯•æ™ºèƒ½ä½“"""
    print("ğŸ¤– æµ‹è¯•æ™ºèƒ½ä½“ç³»ç»Ÿ...")
    try:
        from simple_agent import get_simple_agent

        agent = get_simple_agent()

        test_input = {"input": "å…¬å¸çš„å¹´å‡åˆ¶åº¦æ˜¯æ€æ ·çš„ï¼Ÿ"}
        print(f"â“ é—®é¢˜: {test_input['input']}")

        result = agent.invoke(test_input)
        print(f"ğŸ“ å›ç­”: {result['output'][:150]}...")

        print("âœ… æ™ºèƒ½ä½“æµ‹è¯•é€šè¿‡")

    except Exception as e:
        print(f"âŒ æ™ºèƒ½ä½“æµ‹è¯•å¤±è´¥: {e}")
        return False

    print()
    return True

def test_server():
    """æµ‹è¯•æœåŠ¡å™¨ç»„ä»¶"""
    print("ğŸŒ æµ‹è¯•åç«¯æœåŠ¡å™¨ç»„ä»¶...")
    try:
        # æµ‹è¯•å¯¼å…¥
        from backend.server import app
        print("âœ… FastAPI æœåŠ¡å™¨æ¨¡å—å¯¼å…¥æˆåŠŸ")

        # è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šæµ‹è¯•
        return True

    except Exception as e:
        print(f"âŒ æœåŠ¡å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def show_usage():
    """æ˜¾ç¤ºä½¿ç”¨è¯´æ˜"""
    print("ğŸš€ å¯åŠ¨è¯´æ˜:")
    print("1. å¯åŠ¨åç«¯æœåŠ¡å™¨:")
    print("   uvicorn backend.server:app --reload --port 8000")
    print()
    print("2. å¯åŠ¨å‰ç«¯ç•Œé¢:")
    print("   cd frontend && npm install && npm run dev")
    print()
    print("3. è®¿é—®ç•Œé¢:")
    print("   - React å‰ç«¯: http://localhost:5173")
    print("   - API æ–‡æ¡£: http://localhost:8000/docs")
    print("   - å¥åº·æ£€æŸ¥: http://localhost:8000/health")
    print()
    print("ğŸ’¡ æç¤º:")
    print("   - é¦–æ¬¡è¿è¡Œä¼šè‡ªåŠ¨åˆ›å»ºç¤ºä¾‹æ–‡æ¡£")
    print("   - æ— éœ€ Milvus æ•°æ®åº“å³å¯ä½¿ç”¨åŸºç¡€åŠŸèƒ½")
    print("   - é…ç½® DeepSeek API Key å¯è·å¾—æ›´å¥½ä½“éªŒ")
    print("   - ä½¿ç”¨ API æ¥å£å¯ç›´æ¥æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½")

def main():
    """ä¸»å‡½æ•°"""
    print_banner()

    # æ£€æŸ¥ç¯å¢ƒ
    check_environment()

    # è¿è¡Œæµ‹è¯•
    all_tests_passed = True

    all_tests_passed &= test_rag_engine()
    all_tests_passed &= test_agent()
    all_tests_passed &= test_server()

    # æ˜¾ç¤ºç»“æœ
    print("=" * 60)
    if all_tests_passed:
        print("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ç³»ç»Ÿå·²å‡†å¤‡å°±ç»ªã€‚")
    else:
        print("âš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é”™è¯¯ä¿¡æ¯ã€‚")

    print()
    show_usage()

if __name__ == "__main__":
    main()

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/__init__.py
"""
DeepSeek RAG Backend Package

This package contains the backend server and business logic for the RAG system.
"""

__version__ = "1.0.0"
__author__ = "DeepSeek RAG Team"

## File: /home/liaozhenhao/liao-warehouse/deepseek_rag_project/backend/requirements.txt
# åŸºç¡€ä¾èµ–
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6
pydantic==2.5.0
python-dotenv==1.0.0

# å¼‚æ­¥æ–‡ä»¶æ“ä½œ
aiofiles==23.2.1

# ç°æœ‰RAGç›¸å…³ä¾èµ–ï¼ˆä¿æŒå…¼å®¹ï¼‰
openai==1.3.0
langchain==0.0.340
langchain-openai==0.0.2
pymilvus==2.3.4
sentence-transformers==2.2.2
torch==2.1.0
transformers==4.35.2

# æ–‡æ¡£å¤„ç†
PyPDF2==3.0.1
python-docx==0.8.11

# å…¶ä»–å·¥å…·
requests==2.31.0
numpy==1.24.3

---
*Backend code collection completed. All files have been organized with their absolute paths.*